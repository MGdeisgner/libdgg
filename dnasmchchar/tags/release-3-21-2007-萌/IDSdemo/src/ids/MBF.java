/*
* * 本軟體係應用中華民國發明專利號碼第I254863號「可攜式造字引擎」專利
* 本程式引用專利license:可攜式造字引擎專利公眾授權條款KSAFAEA
* 該條款可在anouncement.zhongwen.tw取得

* Copyright (c) 2007 著作權由張正一所有。著作權人保留一切權利。
*
* 這份授權條款，在使用者符合以下三條件的情形下，授予使用者使用及再散播本
* 軟體包裝原始碼及二進位可執行形式的權利，無論此包裝是否經改作皆然：
* 
* * 對於本軟體原始碼的再散播，必須保留上述的版權宣告、此三條件表列，以
*   及下述的免責聲明。
* * 對於本套件二進位可執行形式的再散播，必須連帶以文件以及／或者其他附
*   於散播包裝中的媒介方式，重製上述之版權宣告、此三條件表列，以及下述
*   的免責聲明。
* * 未獲事前取得書面許可，不得使用張正一或本軟體貢獻者之名稱，
*   來為本軟體之衍生物做任何表示支持、認可或推廣、促銷之行為。
* 
* 免責聲明：本軟體是由張正一及本軟體之貢獻者以現狀（\as is\）提供，
* 本軟體包裝不負任何明示或默示之擔保責任，包括但不限於就適售性以及特定目
* 的的適用性為默示性擔保。張正一及本軟體之貢獻者，無論任何條件、
* 無論成因或任何責任主義、無論此責任為因合約關係、無過失責任主義或因非違
* 約之侵權（包括過失或其他原因等）而起，對於任何因使用本軟體包裝所產生的
* 任何直接性、間接性、偶發性、特殊性、懲罰性或任何結果的損害（包括但不限
* 於替代商品或勞務之購用、使用損失、資料損失、利益損失、業務中斷等等），
* 不負任何責任，即在該種使用已獲事前告知可能會造成此類損害的情形下亦然。
 */

package ids;

/**
 * @author mgdesigner Minimum Bounding Frame，包住部件的最小外框 取得方法是該部件最小的xy與最大的xy
 * 
 *       MBF是Minimum Bounding Frame，是包住部件的最小外框
 *                       取得方法是該部件最小的xy與最大的xy，非最小的(x,y)與最大的(x,y)    
 *                       12/28 把MBF獨立成類別
 */
public class MBF {
    private int 左;//基x基y為框架左上角的點
    private int 上;

    private int 寬;

    private int 高;

    public MBF(CharComponent 甲部件) {
	/**
         * 末級的話，根據筆畫來算 非末級的話，判讀框架的
         */
		 左 = 256;
	    上 = 256;
	    int 右 = 0;
	    int 下 = 0;// 最小框設初值，由左而右依序是左上x,左上y，右下x，右下y
	    	
	    int i = 0;// 位置
	    int tx = 0, ty = 0;// 目前尋訪的點
	if (甲部件.is末級()) { //IF始
//	  -------MBF尋找--------
	    
	    int[] 筆畫=甲部件.get筆畫();
	    //所有點都得尋訪，所以用循序搜尋
	    while (i < 筆畫.length) {// WHILE
			tx = 筆畫[i + 2];
			ty = 筆畫[i + 3];
			if (tx < 左)   左 = tx;// 找MBF左上角
			if (ty < 上)   上 = ty;
			if (右 < tx)   右 = tx;
			if (下 < ty)   下 = ty;// 找MBF右下角
		i += 4;
	    }// WHILE
	    
	    // ------MBF end----------
	} //IF末
	
	else 
	{ //ELSE
	    int[][] 子組件框=甲部件.get子組件框() ;
	   // 字框的結構為：左上角x座標,左上角y座標,寬度,高度
	    /**非末級部件
	    * 左 = 256;
	    * 上 = 256;
	    * mbf_bx = 0;
	    * mbf_by = 0;
		 * 比較各子組件的左上角點，找到極大x,y與極小x,y
		 * */
	    for (i = 0; i < 子組件框.length; i++) { //FOR始
		
		if (子組件框[i][0] < 左)   左 = 子組件框[i][0];// 找最所有框架x最小的
		if (子組件框[i][1] < 上)   上 = 子組件框[i][1];// 找最所有框架y最小的
		int 右下點x=子組件框[i][0]+子組件框[i][2];
		int 右下點y=子組件框[i][1]+子組件框[i][3];
		if (右 < 右下點x)   右 = 右下點x;
		if (下 < 右下點y)   下 = 右下點y;	
		
	    } //FOR末	    
	    
	} //ELSE end
	寬 = 右 - 左+1;//強制+1是為了避開有可能為0的狀況，這樣做可以省去額外的分支跳躍，而只偏移了一點點
	高 = 下 - 上+1;
    }

    public int getX() {
	return 左;
    }

    public int getY() {
	return 上;
    }

    public float getWidth() {
	return 寬;
    }

    public float getHeight() {
	return 高;
    }

}
